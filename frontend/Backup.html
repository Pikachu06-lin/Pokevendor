<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pok√©Vendor AI Card Upload</title>
<style>
  body { font-family: 'Inter', Arial, sans-serif; padding: 20px; max-width: 900px; margin: 0 auto; background-color: #f0f2f5; }
  h1 { color: #333; text-align: center; margin-bottom: 20px; }
  h2 { color: #555; border-bottom: 2px solid #ddd; padding-bottom: 5px; }
  input, button, select { margin: 8px 0; display: block; padding: 10px; width: 100%; box-sizing: border-box; border-radius: 8px; border: 1px solid #ccc; font-size: 16px; }
  label { margin-top: 15px; font-weight: bold; display: block; color: #333; }
  #uploadForm, #loginDiv { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); margin-top: 20px; }
  #uploadForm { display: none; }
  .error { color: #d32f2f; font-weight: bold; margin-top: 10px; background-color: #ffebee; padding: 10px; border-radius: 8px; }
  .success { color: #388e3c; font-weight: bold; margin-top: 10px; background-color: #e8f5e9; padding: 10px; border-radius: 8px; }
  .info { color: #1976d2; font-weight: bold; margin-top: 10px; background-color: #e3f2fd; padding: 10px; border-radius: 8px; }
  #cardSelection { display: none; margin-top: 25px; border: 1px solid #ccc; padding: 20px; border-radius: 12px; background: #fff; box-shadow: 0 4px 10px rgba(0,0,0,0.05); }
  #cardSelection ul { list-style: none; padding: 0; }
  #cardSelection li { margin-bottom: 15px; padding: 15px; background: #f9f9f9; border-radius: 10px; border: 1px solid #eee; display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
  #cardSelection button { width: auto; display: inline-block; background: #4CAF50; color: white; border: none; cursor: pointer; padding: 10px 20px; border-radius: 6px; font-weight: bold; transition: background 0.3s; flex-shrink: 0; }
  #cardSelection button:hover { background: #45a049; }
  #cardSelection button:disabled { background: #ccc; cursor: not-allowed; }
  #loginBtn, #uploadBtn { width: 100%; font-weight: bold; }
  #loginBtn { background: #2196F3; color: white; border: none; cursor: pointer; }
  #loginBtn:hover { background: #0b7dda; }
  #uploadBtn { background: #ff9800; color: white; border: none; cursor: pointer; }
  #uploadBtn:hover { background: #e68900; }
  #uploadBtn:disabled { background: #ccc; cursor: not-allowed; }
  img.card-img { max-width: 70px; height: auto; margin-right: 15px; border-radius: 6px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); flex-shrink: 0; }
  .card-details { flex: 1; min-width: 150px; }
  #imagePreview { max-width: 100%; width: 150px; height: auto; margin-top: 15px; border-radius: 8px; display: none; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
  .logout-btn { background: #f44336; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 6px; margin-top: 10px; float: right; width: auto; }
  .logout-btn:hover { background: #da190b; }
  .price-input-container { margin-right: 15px; display: flex; align-items: center; gap: 5px; flex-shrink: 0; }
  .listed-price-input { width: 80px; padding: 5px; margin: 0; display: inline-block; font-size: 14px; text-align: right; }
  .price-label { font-weight: normal; margin: 0; display: inline-block; font-size: 14px; }
  @media (min-width: 600px) { img.card-img { max-width: 100px; } .price-input-container { margin-left: auto; } }
</style>
</head>
<body>

<h1>üé¥ Pok√©Vendor AI Card Upload</h1>

<div id="loginDiv">
  <h2>Admin Login</h2>
  <input type="email" id="email" placeholder="Email" value="">
  <input type="password" id="password" placeholder="Password" value="">
  <button id="loginBtn">Login</button>
  <div id="loginMsg"></div>
</div>

<div id="uploadForm">
  <h2>Upload Card Image for AI Identification</h2>
  <button class="logout-btn" id="logoutBtn">Logout</button>
  <div style="clear: both;"></div>
  
  <label for="cardImage">Image File:</label>
  <input type="file" id="cardImage" name="cardImage" accept="image/*" required>
  <img id="imagePreview" alt="Card preview">
  
  <input type="text" id="cardName" placeholder="Override card name (optional)"> 

  <label for="language">Card Language:</label>
  <select id="language" name="language">
    <option value="en">English</option>
    <option value="ja">Japanese (Êó•Êú¨Ë™û)</option>
    <option value="fr">French</option>
    <option value="de">German</option>
    <option value="es">Spanish</option>
    <option value="it">Italian</option>
    <option value="pt">Portuguese</option>
  </select>

  <label for="condition">Card Condition:</label>
  <select id="condition" name="condition">
    <option value="Near Mint">Near Mint</option>
    <option value="Lightly Played">Lightly Played</option>
    <option value="Moderately Played">Moderately Played</option>
    <option value="Heavily Played">Heavily Played</option>
    <option value="Damaged">Damaged</option>
  </select>

  <button id="uploadBtn">üîç Identify & Select Card</button>
  <div id="uploadMsg"></div>
</div>

<div id="cardSelection">
  <h3>Select the correct card and set your listed price:</h3>
  <ul id="cardList"></ul>
</div>

<script>
const GEMINI_API_KEY = "AIzaSyBARE5MGIBfME4xWWNp6-1tcPcBvDt5mG8";

const config = {
  backendUrl: "http://localhost:5000",
  loginEndpoint: "/api/auth/login",
  addCardEndpoint: "/api/cards/identify"
};

let token = null;

document.getElementById('cardImage').addEventListener('change', function(e) {
  const file = e.target.files[0];
  const preview = document.getElementById('imagePreview');
  
  if (file) {
    const reader = new FileReader();
    reader.onload = function(e) {
      preview.src = e.target.result;
      preview.style.display = 'block';
    };
    reader.readAsDataURL(file);
  } else {
    preview.style.display = 'none';
  }
});

document.getElementById('loginBtn').addEventListener('click', async function() {
  const email = document.getElementById('email').value.trim();
  const password = document.getElementById('password').value;
  const loginMsgDiv = document.getElementById('loginMsg');
  const loginBtn = document.getElementById('loginBtn');

  if (!email || !password) {
    loginMsgDiv.textContent = "‚ùå Please enter both email and password";
    loginMsgDiv.className = "error";
    return;
  }

  loginBtn.disabled = true;
  loginMsgDiv.textContent = "Logging in...";
  loginMsgDiv.className = "info";

  try {
    const loginEndpoint = config.backendUrl + config.loginEndpoint;
    const resp = await fetch(loginEndpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email: email, password: password })
    });
    
    let data;
    const contentType = resp.headers.get("content-type");
    
    if (contentType && contentType.includes("application/json")) {
      data = await resp.json();
    } else {
      const text = await resp.text();
      console.error("Non-JSON response:", text.substring(0, 500));
      throw new Error("Server returned HTML instead of JSON (Status: " + resp.status + ")");
    }

    if (!resp.ok) {
      throw new Error(data.message || data.error || "Login failed with status " + resp.status);
    }

    token = data.token;
    loginMsgDiv.textContent = "‚úÖ Logged in successfully!";
    loginMsgDiv.className = "success";
    
    setTimeout(function() {
      document.getElementById('uploadForm').style.display = "block";
      document.getElementById('loginDiv').style.display = "none";
    }, 500);

  } catch(err) {
    loginMsgDiv.textContent = "‚ùå " + (err.message || "Login failed");
    loginMsgDiv.className = "error";
    console.error("Login error:", err);
  } finally {
    loginBtn.disabled = false;
  }
});

document.getElementById('logoutBtn').addEventListener('click', function() {
  token = null;
  document.getElementById('uploadForm').style.display = "none";
  document.getElementById('loginDiv').style.display = "block";
  document.getElementById('cardSelection').style.display = "none";
  document.getElementById('cardImage').value = '';
  document.getElementById('imagePreview').style.display = 'none';
  document.getElementById('uploadMsg').textContent = '';
});

async function identifyCardWithGemini(base64Image, targetLanguage) {
  const manualName = document.getElementById('cardName').value.trim();
  
  if (manualName) {
    return { name: manualName, set: null, setNumber: null, confidence: 1.0 };
  }
  
  try {
    let languageInstruction = "";
    if (targetLanguage === 'ja') {
      languageInstruction = " Return the card name in JAPANESE characters (e.g., „Éî„Ç´„ÉÅ„É•„Ç¶VMAX). This is very important - use Japanese text for name and set.";
    } else if (targetLanguage === 'en') {
      languageInstruction = " Return the card name in ENGLISH.";
    } else {
      languageInstruction = " Return the card name in the language that matches: " + targetLanguage;
    }

    const prompt = "Identify this Pok√©mon card from the image and return only a JSON object with the following keys: name, set, setNumber, rarity, language." + languageInstruction + " Do not include any other text.";

    const mimeType = base64Image.split(';')[0].split(':')[1];
    const data = base64Image.split(',')[1];

    const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=" + GEMINI_API_KEY, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{
          parts: [
            { text: prompt },
            { inline_data: { mime_type: mimeType, data: data } }
          ]
        }]
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error("Gemini API error: " + response.status + " - " + errorText);
    }

    const result = await response.json();
    const textContent = result.candidates && result.candidates[0] && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts[0] && result.candidates[0].content.parts[0].text;
    
    if (!textContent) {
      throw new Error("No response from Gemini AI");
    }

    let jsonText = textContent.trim();
    jsonText = jsonText.replace(/```json\n?/g, '').replace(/```\n?/g, '');
    
    const cardInfo = JSON.parse(jsonText);
    
    if (!cardInfo.name) {
      throw new Error("AI did not identify a card name");
    }
    
    console.log("AI Identified Card:", cardInfo);
    return cardInfo;
    
  } catch (err) {
    console.error("Gemini identification error:", err);
    throw new Error("AI identification failed: " + err.message);
  }
}

async function fetchCardsFromTCGdex(name, setName, language) {
  if (!name) return [];
  
  try {
    console.log("Searching TCGdex for: " + name + " (Language: " + language + ")");
    
    const cardsUrl = "https://api.tcgdex.net/v2/" + language + "/cards";
    const resp = await fetch(cardsUrl);
    
    if (!resp.ok) {
      throw new Error("TCGdex API error: " + resp.status);
    }
    
    const allCards = await resp.json();
    console.log("TCGdex returned " + allCards.length + " total cards");
    
    // Normalize search term - try multiple variations
    const nameLower = name.toLowerCase().trim();
    const nameVariations = [
      nameLower,
      nameLower.replace(/&/g, 'ÔºÜ'),  // Full-width ampersand
      nameLower.replace(/&/g, 'and'),
      nameLower.replace(/&/g, ' '),
      nameLower.replace(/\s+/g, ''),  // Remove spaces
      nameLower.replace(/[&ÔºÜ]/g, '') // Remove ampersands
    ];
    
    console.log("Trying name variations:", nameVariations);
    
    let matchingCards = allCards.filter(function(card) {
      if (!card.name) return false;
      const cardNameLower = card.name.toLowerCase();
      
      // Try exact and partial matches with all variations
      return nameVariations.some(function(variation) {
        return cardNameLower.includes(variation) || variation.includes(cardNameLower);
      });
    });
    
    // If no matches, try more lenient search (split by spaces and match any word)
    if (matchingCards.length === 0) {
      const keywords = nameLower.split(/[\s&ÔºÜ]+/).filter(function(word) {
        return word.length > 2; // Only words with 3+ characters
      });
      
      console.log("Trying keyword search:", keywords);
      
      matchingCards = allCards.filter(function(card) {
        if (!card.name) return false;
        const cardNameLower = card.name.toLowerCase();
        
        // Match if card name contains most of the keywords
        const matchCount = keywords.filter(function(keyword) {
          return cardNameLower.includes(keyword);
        }).length;
        
        return matchCount >= Math.max(1, keywords.length - 1); // Allow one missing keyword
      });
    }
    
    console.log("Found " + matchingCards.length + " cards matching name");
    
    if (setName && matchingCards.length > 0) {
      const setLower = setName.toLowerCase().trim();
      const setFiltered = matchingCards.filter(function(card) {
        const cardSetName = (card.set && card.set.name && card.set.name.toLowerCase()) || '';
        const cardSetId = (card.set && card.set.id && card.set.id.toLowerCase()) || '';
        return cardSetName.includes(setLower) || cardSetId.includes(setLower);
      });
      
      if (setFiltered.length > 0) {
        matchingCards = setFiltered;
        console.log("Filtered to " + matchingCards.length + " cards in set");
      }
    }
    
    if (matchingCards.length === 0) {
      return [];
    }
    
    const detailedCards = await Promise.all(
      matchingCards.slice(0, 40).map(async function(card) {
        try {
          const cardId = card.id;
          
          if (!cardId) {
            return card;
          }
          
          const detailUrl = "https://api.tcgdex.net/v2/" + language + "/cards/" + cardId;
          const detailResp = await fetch(detailUrl);
          
          if (detailResp.ok) {
            const detailedCard = await detailResp.json();
            console.log("Fetched detailed card:", detailedCard.name);
            return detailedCard;
          }
          return card;
        } catch (err) {
          console.error("Error fetching details:", err);
          return card;
        }
      })
    );
    
    const validCards = detailedCards.filter(function(c) {
      return c !== null && c !== undefined;
    });
    
    console.log("Successfully fetched " + validCards.length + " detailed cards");
    return validCards;
    
  } catch (err) {
    console.error("TCGdex API fetch error:", err);
    throw err;
  }
}

function extractMarketPrice(card) {
  try {
    console.log("Extracting price from card:", card.name);
    console.log("Full pricing object:", card.pricing);
    
    // TCGdex stores pricing under card.pricing
    if (card.pricing) {
      // Try TCGplayer first (USD)
      if (card.pricing.tcgplayer) {
        const tcp = card.pricing.tcgplayer;
        console.log("TCGplayer pricing found:", tcp);
        
        // Check for holofoil variant (most common for special cards)
        if (tcp.holofoil && tcp.holofoil.marketPrice) {
          console.log("Found holofoil marketPrice: $" + tcp.holofoil.marketPrice);
          return tcp.holofoil.marketPrice.toFixed(2);
        }
        
        // Check for reverseHolofoil variant
        if (tcp.reverseHolofoil && tcp.reverseHolofoil.marketPrice) {
          console.log("Found reverseHolofoil marketPrice: $" + tcp.reverseHolofoil.marketPrice);
          return tcp.reverseHolofoil.marketPrice.toFixed(2);
        }
        
        // Check for normal variant
        if (tcp.normal && tcp.normal.marketPrice) {
          console.log("Found normal marketPrice: $" + tcp.normal.marketPrice);
          return tcp.normal.marketPrice.toFixed(2);
        }
        
        // Check for 1stEdition variant
        if (tcp['1stEdition'] && tcp['1stEdition'].marketPrice) {
          console.log("Found 1stEdition marketPrice: $" + tcp['1stEdition'].marketPrice);
          return tcp['1stEdition'].marketPrice.toFixed(2);
        }
        
        // Check for unlimitedHolofoil variant
        if (tcp.unlimitedHolofoil && tcp.unlimitedHolofoil.marketPrice) {
          console.log("Found unlimitedHolofoil marketPrice: $" + tcp.unlimitedHolofoil.marketPrice);
          return tcp.unlimitedHolofoil.marketPrice.toFixed(2);
        }
      }
      
      // Try Cardmarket (EUR)
      if (card.pricing.cardmarket) {
        const cm = card.pricing.cardmarket;
        console.log("Cardmarket pricing found:", cm);
        
        // Cardmarket has direct avg, trend, low prices
        if (cm.avg) {
          console.log("Found Cardmarket avg price: ‚Ç¨" + cm.avg);
          return cm.avg.toFixed(2);
        }
        if (cm.trend) {
          console.log("Found Cardmarket trend price: ‚Ç¨" + cm.trend);
          return cm.trend.toFixed(2);
        }
        if (cm.low) {
          console.log("Found Cardmarket low price: ‚Ç¨" + cm.low);
          return cm.low.toFixed(2);
        }
      }
    } else {
      console.log("No pricing field found on card");
    }
    
    console.log("No pricing found for card:", card.name);
    return null;
  } catch (err) {
    console.error("Error extracting price:", err);
    return null;
  }
}

document.getElementById('uploadBtn').addEventListener('click', async function() {
  const file = document.getElementById('cardImage').files[0];
  const condition = document.getElementById('condition').value;
  const language = document.getElementById('language').value;
  const uploadMsgDiv = document.getElementById('uploadMsg');
  const uploadBtn = document.getElementById('uploadBtn');

  if (!file) {
    uploadMsgDiv.textContent = "‚ùå Image file is required.";
    uploadMsgDiv.className = "error";
    return;
  }

  uploadBtn.disabled = true;
  uploadMsgDiv.textContent = "ü§ñ Processing image with AI...";
  uploadMsgDiv.className = "info";

  try {
    const base64 = await new Promise(function(resolve, reject) {
      const reader = new FileReader();
      reader.onload = function() { resolve(reader.result); };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });

    const aiCard = await identifyCardWithGemini(base64, language);
    if (!aiCard || !aiCard.name) {
      throw new Error("AI failed to identify card.");
    }

    uploadMsgDiv.textContent = "üîç Searching TCGdex for " + aiCard.name + "...";
    
    const cards = await fetchCardsFromTCGdex(aiCard.name, aiCard.set, language);
    
    if (cards.length === 0) {
      throw new Error("No matching cards found for " + aiCard.name);
    }

    const listEl = document.getElementById('cardList');
    listEl.innerHTML = '';
    
    cards.forEach(function(c, idx) {
      const li = document.createElement('li');
      
      console.log('Full card object:', c);
      
      const marketPrice = extractMarketPrice(c);
      
      // For cards without market price (like Japanese cards), suggest a default
      let defaultPrice = '10.00'; // Default for cards with no pricing
      if (marketPrice) {
        defaultPrice = marketPrice;
      }
      
      const priceNote = marketPrice ? '' : ' (Market price unavailable - please set manually)';
      
      let imageUrl = 'https://placehold.co/70x100/94A3B8/ffffff?text=No+Image';
      
      if (c.image) {
        if (typeof c.image === 'string') {
          // TCGdex returns base URL without extension - try different formats
          imageUrl = c.image + '/high.webp'; // Try webp first (smaller, modern)
          console.log("Image URL constructed: " + imageUrl);
        } else if (typeof c.image === 'object') {
          if (c.image.small) {
            imageUrl = c.image.small;
            console.log("Image from object.small: " + imageUrl);
          } else if (c.image.high) {
            imageUrl = c.image.high;
            console.log("Image from object.high: " + imageUrl);
          }
        }
      }
      
      // Also try fallback formats if webp fails
      const imageFallback = c.image ? c.image + '/high.jpg' : imageUrl;
      
      console.log("Card: " + c.name + ", Image: " + imageUrl + ", Price: " + (marketPrice || 'N/A'));
      
      const cardName = c.name || 'Unknown';
      const setName = (c.set && c.set.name) || 'Unknown Set';
      const cardNumber = c.localId || c.id || '?';
      const cardRarity = c.rarity || 'Unknown';
      const priceDisplay = marketPrice ? '$' + marketPrice : 'N/A';
      
      li.innerHTML = '<img src="' + imageUrl + '" alt="' + cardName + '" class="card-img" onerror="this.onerror=null; this.src=\'' + imageFallback + '\'; if(this.src===\'' + imageFallback + '\') this.onerror=function(){this.src=\'https://placehold.co/70x100/94A3B8/ffffff?text=No+Image\';};">' +
        '<div class="card-details">' +
          '<strong>' + cardName + '</strong><br>' +
          '<small>' + setName + ' ‚Ä¢ #' + cardNumber + ' ‚Ä¢ ' + cardRarity + '</small><br>' +
          '<small>Market Price: ' + priceDisplay + priceNote + '</small>' +
        '</div>' +
        '<div class="price-input-container">' +
          '<label class="price-label">List Price ($):</label>' +
          '<input type="number" step="0.01" min="0.01" value="' + defaultPrice + '" class="listed-price-input" data-index="' + idx + '">' +
        '</div>' +
        '<button data-index="' + idx + '">Add to Inventory</button>';
      
      listEl.appendChild(li);
    });

    document.getElementById('cardSelection').style.display = 'block';
    uploadMsgDiv.textContent = "‚úÖ Found " + cards.length + " matching cards";
    uploadMsgDiv.className = "success";

    listEl.querySelectorAll('button').forEach(function(btn) {
      btn.addEventListener('click', async function() {
        const idx = parseInt(btn.dataset.index);
        const selectedCard = cards[idx];
        
        const priceInput = document.querySelector('.listed-price-input[data-index="' + idx + '"]');
        const listedPriceRaw = priceInput ? priceInput.value : null;
        
        if (!listedPriceRaw || isNaN(parseFloat(listedPriceRaw)) || parseFloat(listedPriceRaw) <= 0) {
          alert("‚ùå Please enter a valid listed price greater than $0.00.");
          return;
        }
        const listedPrice = parseFloat(listedPriceRaw);
        
        btn.disabled = true;
        btn.textContent = 'Adding...';
        
        try {
          const marketPrice = extractMarketPrice(selectedCard);
          
          let imageUrl = null;
          if (selectedCard.image) {
            if (typeof selectedCard.image === 'string') {
              imageUrl = selectedCard.image;
            } else if (selectedCard.image.small) {
              imageUrl = selectedCard.image.small;
            } else if (selectedCard.image.high) {
              imageUrl = selectedCard.image.high;
            }
          }
          
          const cardPayload = {
            mode: "1", 
            name: selectedCard.name,
            set: (selectedCard.set && selectedCard.set.name) || 'Unknown Set',
            number: selectedCard.localId || selectedCard.id || '',
            rarity: selectedCard.rarity || 'Unknown',
            language: language === 'ja' ? 'Japanese' : (language === 'en' ? 'English' : language), 
            condition: condition,
            marketprice: marketPrice,
            listedprice: listedPrice,
            availability: true,
            imageurl: imageUrl
          };
          
          console.log("Sending card payload:", cardPayload);
          
          const resp = await fetch(config.backendUrl + config.addCardEndpoint, {
            method: "POST",
            headers: { 
              "Authorization": "Bearer " + token,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(cardPayload)
          });

          let result;
          const contentType = resp.headers.get("content-type");
          
          if (contentType && contentType.includes("application/json")) {
            result = await resp.json();
          } else {
            const text = await resp.text();
            console.error("Non-JSON response:", text.substring(0, 500));
            throw new Error("Server returned HTML instead of JSON");
          }
          
          if (!resp.ok) {
            throw new Error(result.error || result.message || "Server error");
          }

          alert("‚úÖ Card added to inventory!");
          
          document.getElementById('cardSelection').style.display = 'none';
          document.getElementById('cardImage').value = '';
          document.getElementById('cardName').value = '';
          document.getElementById('imagePreview').style.display = 'none';
          uploadMsgDiv.textContent = "";
          
        } catch(err) {
          alert("‚ùå Failed to add card: " + err.message);
          console.error("Add card error:", err);
          btn.disabled = false;
          btn.textContent = 'Add to Inventory';
        }
      });
    });

  } catch(err) {
    uploadMsgDiv.textContent = "‚ùå " + err.message;
    uploadMsgDiv.className = "error";
    console.error("Upload error:", err);
  } finally {
    uploadBtn.disabled = false;
  }
});

document.getElementById('password').addEventListener('keypress', function(e) {
  if (e.key === 'Enter') document.getElementById('loginBtn').click();
});

document.getElementById('email').addEventListener('keypress', function(e) {
  if (e.key === 'Enter') document.getElementById('loginBtn').click();
});
</script>

</body>
</html>